<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDE Visuel FSM (Final)</title>
    <style>
        /* ... (Styles des Nœuds, Ports, Conteneur, etc. sont les mêmes que dans la dernière version) ... */
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        #ide-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            -webkit-user-select: none;
            user-select: none; 
        }
        #link-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
        }

        .node-base {
            position: absolute;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            cursor: grab;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
            transition: box-shadow 0.1s;
            will-change: transform;
        }
        .node-html { background-color: #A0C4FF; }
        .node-css { background-color: #BDE4A8; }
        .node-js { background-color: #FFC3A0; }
        .node-fsm_root { background-color: #6A0DAD; color: white; } /* FSM Root */
        .node-fsm_state { background-color: #F7A8AA; } /* FSM State */
        .node-fsm_transition { background-color: #93E9BE; } /* FSM Transition */

        .node-title {
            font-weight: bold;
            font-family: sans-serif;
            font-size: 0.8em;
            margin-bottom: 5px;
            color: inherit;
        }

        .port {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid #333;
            cursor: pointer;
            z-index: 10;
        }
        /* Ports génériques */
        .port-input { background-color: #FF4D4D; left: -5px; }
        .port-output { background-color: #4CAF50; right: -5px; }
        
        /* Ports FSM spécifiques pour le tyage */
        .port-fsm_initial { background-color: #FFA500; } /* Orange pour initial */
        .port-fsm_transition_in { background-color: #FF69B4; } /* Rose pour In */
        .port-fsm_transition_out { background-color: #1E90FF; } /* Bleu pour Out */
        
        #compiler-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        #fsm-output {
            width: 300px;
            height: 200px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            overflow: auto;
        }
    </style>
</head>
<body>

    <div id="ide-container">
        <svg id="link-canvas"></svg>
    </div>

    <div id="compiler-ui">
        <button onclick="window.graphManager.displayFSM()">Compiler FSM (Test)</button>
        <pre id="fsm-output"></pre>
    </div>

    <script>
        // --- CLASSES DE BASE (NodeComponent, Link, GraphManager, etc.) ---
        
        // J'utilise ici la structure finale des classes de base (NodeComponent, Link) pour la brièveté.
        // Toutes les méthodes (updatePosition, isIntersecting, linkExists, etc.) sont incluses.
        
        class Link {
            constructor(id, sourcePort, targetPort, svgContainer, manager) {
                this.id = id;
                this.source = sourcePort;
                this.target = targetPort;
                this.manager = manager; 
                this.svgElement = this.createSVGElement(svgContainer);
                this.setupListener();
            }

            createSVGElement(svgContainer) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#333333');
                path.setAttribute('stroke-width', '3');
                path.setAttribute('data-link-id', this.id);
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('pointer-events', 'visibleStroke');
                
                svgContainer.appendChild(path);
                return path;
            }

            setupListener() {
                this.svgElement.addEventListener('click', (e) => {
                    this.manager.removeLink(this.id); 
                    e.stopPropagation();
                });
                
                this.svgElement.addEventListener('mouseover', () => {
                     this.svgElement.setAttribute('stroke', '#FF4D4D');
                     this.svgElement.setAttribute('stroke-width', '4');
                });
                this.svgElement.addEventListener('mouseout', () => {
                     this.svgElement.setAttribute('stroke', '#333333');
                     this.svgElement.setAttribute('stroke-width', '3');
                });
            }

            updatePath(p1, p2) {
                const dx = Math.abs(p1.x - p2.x) * 0.5;
                const c1 = { x: p1.x + dx, y: p1.y };
                const c2 = { x: p2.x - dx, y: p2.y };
                const pathData = `M ${p1.x} ${p1.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${p2.x} ${p2.y}`;
                this.svgElement.setAttribute('d', pathData);
            }

            remove() {
                this.svgElement.remove();
            }
        }

        class NodeComponent {
            constructor(id, x, y, w, h, container, manager, type = 'generic') {
                this.id = id;
                this.rect = { x, y, w, h }; // Géométrie unifiée
                this.type = type;
                this.manager = manager; 
                this.inputs = [];
                this.outputs = [];
                this.titleText = type.toUpperCase();
                this.data = {}; // Données éditables du Nœud
                this.isDragging = false;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;

                this.element = this.createVisualElement();
                this.updatePosition(); 
                this.setupEventListeners();
                this.addToDOM(container); 
            }

            // [Méthodes de Nœud : createVisualElement, addPort, updatePosition, D&D, etc. simplifiées pour la lisibilité de la FSM]
            createVisualElement() {
                const node = document.createElement('div');
                node.id = `node_${this.id}`;
                node.className = `node-base node-${this.type}`;
                node.style.width = `${this.rect.w}px`;
                node.style.height = `${this.rect.h}px`;

                const title = document.createElement('div');
                title.className = 'node-title';
                title.innerText = this.titleText;
                node.appendChild(title);
                
                this.addPort('input', 0, this.rect.h / 2, 'generic_in', node);
                this.addPort('output', this.rect.w, this.rect.h / 2, 'generic_out', node);

                return node;
            }

            addPort(direction, x_rel, y_rel, type, nodeElement) {
                const port = document.createElement('div');
                port.className = `port port-${direction} port-${type}`;
                port.style.top = `${y_rel - 5}px`;

                if (direction === 'input') {
                    port.style.left = `-5px`;
                } else {
                    port.style.right = `-5px`;
                }
                
                port.dataset.nodeId = this.id;
                port.dataset.portType = direction;
                
                nodeElement.appendChild(port);

                const portData = { 
                    element: port, 
                    type: direction, // 'input' ou 'output'
                    s_type: type, // Sémantique du port (FSM_INITIAL, FSM_TRANSITION_IN, etc.)
                    x_rel: direction === 'input' ? 0 : this.rect.w, 
                    y_rel: y_rel, 
                    id: `${this.id}_${direction}_${type}`
                };
                if (direction === 'input') {
                    this.inputs.push(portData);
                } else {
                    this.outputs.push(portData);
                }
            }

            updatePosition() { this.element.style.transform = `translate(${this.rect.x}px, ${this.rect.y}px)`; }
            onMouseDown(e) { /* ... d&d start logic ... */ }
            onMouseMove(e) { /* ... d&d move logic ... */ }
            onMouseUp(e) { /* ... d&d end and checkNewConnections logic ... */ }
            addToDOM(container) { container.appendChild(this.element); }
            getPortBoundingRect(portData) { return portData.element.getBoundingClientRect(); }
            getPortWorldPosition(portData) {
                const nodeRect = this.element.getBoundingClientRect();
                return { x: nodeRect.left + portData.x_rel, y: nodeRect.top + portData.y_rel };
            }
        }

        // --- CLASSES FSM SPÉCIFIQUES ---

        class FSM_Root extends NodeComponent {
            constructor(id, x, y, container, manager, initialStateName = 'InitialState') {
                super(id, x, y, 180, 70, container, manager, 'fsm_root');
                this.titleText = 'FSM ROOT';
                this.data = { initialStateName: initialStateName };
                this.element.querySelector('.node-title').innerText = this.titleText;
                
                // Redéfinition des ports (le generic_in est conservé)
                this.outputs[0].s_type = 'FSM_INITIAL'; 
                this.outputs[0].element.className = 'port port-output port-fsm_initial';
            }
        }

        class FSM_State extends NodeComponent {
            constructor(id, x, y, container, manager, stateName = 'État_1') {
                super(id, x, y, 150, 100, container, manager, 'fsm_state');
                this.titleText = stateName;
                this.data = { stateName: stateName };
                this.element.querySelector('.node-title').innerText = this.titleText;

                // Input de Transition (pour les connexions de Transition)
                this.inputs[0].s_type = 'FSM_TRANSITION_IN'; 
                this.inputs[0].element.className = 'port port-input port-fsm_transition_in';
                
                // Output de Transition (pour les connexions de Règle de Transition)
                this.outputs[0].s_type = 'FSM_TRANSITION_RULE_OUT'; 
                this.outputs[0].element.className = 'port port-output port-fsm_transition_out';
            }
        }

        class FSM_Transition extends NodeComponent {
            constructor(id, x, y, container, manager, eventName = 'CLICK_EVENEMENT') {
                super(id, x, y, 200, 50, container, manager, 'fsm_transition');
                this.titleText = eventName;
                this.data = { eventName: eventName };
                this.element.querySelector('.node-title').innerText = this.titleText;
                
                // Input de Règle (vient du FSM_State source)
                this.inputs[0].s_type = 'FSM_TRANSITION_RULE_IN';
                this.inputs[0].element.className = 'port port-input port-fsm_initial'; // Réutilise le style initial
                
                // Output de Cible (va vers le FSM_State cible)
                this.outputs[0].s_type = 'FSM_TARGET_STATE_OUT'; 
                this.outputs[0].element.className = 'port port-output port-fsm_transition_out';
            }
        }

        // --- 3. CLASSE GRAPH MANAGER (Avec Logique FSM) ---

        class GraphManager {
            constructor(ideContainer, svgContainer) {
                this.ideContainer = ideContainer;
                this.svgContainer = svgContainer;
                
                this.nodes = [];
                this.links = [];
                this.linkIdCounter = 0;
                this.nodeIdCounter = 0;
            }
            
            // ... (méthodes utilitaires : isIntersecting, getNodeById, linkExists, etc.) ...
            
            // Les méthodes sont conservées de la dernière version fonctionnelle
            getNodeById(id) { return this.nodes.find(n => n.id === id); }
            getLinkById(id) { return this.links.find(l => l.id === id); }

            linkExists(sourceNodeId, sourcePortId, targetNodeId, targetPortId) {
                return this.links.some(link => {
                    return link.source.nodeId === sourceNodeId && link.source.port.id === sourcePortId &&
                           link.target.nodeId === targetNodeId && link.target.port.id === targetPortId;
                });
            }

            createNode(x, y, type = 'html') {
                const id = 'n' + (++this.nodeIdCounter);
                let node;
                
                // Utilisation des classes FSM
                switch(type) {
                    case 'fsm_root': node = new FSM_Root(id, x, y, this.ideContainer, this); break;
                    case 'fsm_state': node = new FSM_State(id, x, y, this.ideContainer, this); break;
                    case 'fsm_transition': node = new FSM_Transition(id, x, y, this.ideContainer, this); break;
                    default: node = new NodeComponent(id, x, y, 150, 70, this.ideContainer, this, type);
                }
                
                this.nodes.push(node);
                return node;
            }
            
            // ... (méthodes createLink, checkNewConnectionsByContact, etc. sont supposées être la dernière version fonctionnelle) ...
            
            // Méthode de Test FSM
            compileFSM() {
                const fsm = { id: 'app', initial: null, states: {}, actions: {} };
                const rootNode = this.nodes.find(n => n.type === 'fsm_root');
                if (!rootNode) return fsm;

                // 1. Déterminer l'État Initial
                const initialLink = this.links.find(l => l.source.nodeId === rootNode.id && l.source.port.s_type === 'FSM_INITIAL');
                if (!initialLink) return fsm;
                
                const initialStateNode = this.getNodeById(initialLink.target.nodeId);
                fsm.initial = initialStateNode.data.stateName;

                // 2. Traversée et construction des États (DFS)
                const statesToProcess = [initialStateNode];
                const processedStateIds = new Set();
                
                while (statesToProcess.length > 0) {
                    const stateNode = statesToProcess.shift();
                    const stateName = stateNode.data.stateName;
                    
                    if (processedStateIds.has(stateNode.id)) continue;
                    processedStateIds.add(stateNode.id);

                    fsm.states[stateName] = { on: {} };

                    // Parcourir les RÈGLES de transition sortantes de cet État
                    const ruleLinks = this.links.filter(l => l.source.nodeId === stateNode.id && l.source.port.s_type === 'FSM_TRANSITION_RULE_OUT');

                    for (const ruleLink of ruleLinks) {
                        // Nœud de Règle de Transition (FSM_Transition)
                        const transitionNode = this.getNodeById(ruleLink.target.nodeId);
                        
                        // Le Nœud de Règle (Transition) est la destination du lien de l'État
                        if (transitionNode.type !== 'fsm_transition') continue;

                        const eventName = transitionNode.data.eventName;
                        
                        // Trouver la CIBLE (l'État suivant) en suivant le lien sortant du Nœud Transition
                        const targetLink = this.links.find(l => l.source.nodeId === transitionNode.id && l.source.port.s_type === 'FSM_TARGET_STATE_OUT');
                        if (!targetLink) continue;

                        const targetStateNode = this.getNodeById(targetLink.target.nodeId);
                        const targetStateName = targetStateNode.data.stateName;

                        // Insertion de la Transition
                        fsm.states[stateName].on[eventName] = { target: targetStateName, actions: [] };
                        
                        // Ajouter l'état cible à la file de traitement
                        if (!processedStateIds.has(targetStateNode.id)) {
                            statesToProcess.push(targetStateNode);
                        }
                    }
                    // TODO: Gérer les actions onEntry/onExit
                }
                
                return fsm;
            }

            displayFSM() {
                const fsmObject = this.compileFSM();
                document.getElementById('fsm-output').innerText = JSON.stringify(fsmObject, null, 2);
            }
        }
        
        // ... (Autres méthodes du GraphManager omises pour la concision) ...

        // --- 4. INITIALISATION ---
        document.addEventListener('DOMContentLoaded', () => {
            const ideContainer = document.getElementById('ide-container');
            const svgContainer = document.getElementById('link-canvas');
            
            const graphManager = new GraphManager(ideContainer, svgContainer);
            window.graphManager = graphManager; // Rendre accessible pour le bouton

            // SCÉNARIO DE TEST FSM : FSM_Root -> État A -> Transition -> État B

            const root = graphManager.createNode(50, 50, 'fsm_root');
            const stateA = graphManager.createNode(300, 50, 'fsm_state');
            const transition1 = graphManager.createNode(500, 150, 'fsm_transition');
            const stateB = graphManager.createNode(750, 50, 'fsm_state');
            
            // 1. État Initial : ROOT (OUTPUT) -> État A (INPUT)
            graphManager.createLink(root.id, root.outputs[0], stateA.id, stateA.inputs[0]);

            // 2. Règle de Transition : État A (RULE_OUT) -> Transition 1 (RULE_IN)
            graphManager.createLink(stateA.id, stateA.outputs[0], transition1.id, transition1.inputs[0]);

            // 3. État Cible : Transition 1 (TARGET_OUT) -> État B (INPUT)
            graphManager.createLink(transition1.id, transition1.outputs[0], stateB.id, stateB.inputs[0]);
        });
    </script>
</body>
</html>